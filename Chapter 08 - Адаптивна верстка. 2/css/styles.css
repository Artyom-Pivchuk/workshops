/*====================================================ПИКСЕЛИ=========================================================================*/
/*  Физический пиксель - это пиксель, который находится на матрице нашего монитора или экрана. Его можно увидеть на разобранной матрице*/ 

/*  Виртуальный пиксель - это понятие абстрактное. Его уже потрогать и увидеть нельзя - это те пиксели, которые мы задаём в CSS,
    их также называют CSS-пикселями. И не всегда один виртуальный пиксель равен одному физическому пикселю. Если мы укажем в CSS-свойствах
    к примеру ширину 200 пикселей, не на всех мониторах засветится 200 физических пикселей. На разных мониторах в один виртуальный пиксель
    может помещаться разное количество физических пикселей (на практике  к примеру в один виртуальный пиксель может "влазить" 4 физических пикселя)
    Чем больше физических пикселей "влазит" в один виртуальный, тем чётче картинка. Чколько физических пикселей "влазит" в виртуальный пиксель - 
    это и есть плотность пикселей - помечается как 2х, 3х, 4х. 
    2х мониторы - те мониторы, у которых в один виртуальный пиксель помещаются 4 физических пикселя - 2 по высоте и 2 по ширине.*/

/*====================================================ПИКСЕЛИ=========================================================================*/

body {
    height: 100vh;
}

.container {
    width: 950px;
    margin: 0 auto;
}

.banner {
    min-height: 600px;
    background-image: url('../images/car.jpg');
    background-position: center;
    background-size: 960px 576px;
    background-repeat: no-repeat;
}

.team-list {
    display: flex;
    justify-content: space-between;
}

/* 
  96dpi - 1x
  115dpi - 1.2x
  144dpi - 1.5x
  192dpi - 2x
  288dpi - 3x
*/

/*  dpi - количество физических пикселей на дюйм экрана устройства*/
/*  dppx - количество физических пикселей в одном CSS-пикселе, другими словами - это плотность пикселей */

@media (min-device-pixel-ratio: 2), (min-resolution: 192dpi), (min-resolution: 2dpx) {
    .banner {
        background-image: url('../images/car@2x.jpg');
    }
}

/*  Медиа-правило сработает, когда выполнится хотя-бы одно условие. По сути каждое из этих трёх условий выполнится для 2х мониторов.
    Прописываются именно эти три условия для разных браузеров - какие-то браузеры поймут первое условие, какие-то - второе условие,
    какие-то - третье. А если хоть какое-то из условий выполнится тогда @media сработает и распакуется. Поскольку мы указываем во всех 
    трёх условиях минимальное разрешение (min-device-pixel-ratio, min-resolution) - из этого следует будет работать не только для 2х
    мониторов но и для большие значений. Когда медиа-правило сработает, оно распакует нам CSS-свойства нашего блока .banner и таким
    образом мы поменяем ему фоновое изображение background-image на такое же только с высоким разрешением. Посмотреть как работате правило можно
    в браузере во вкладке инструментов разработчика, добавив в настройках переключатель DPR который иметирует экраны с повышенной пиксельной 
    плотностью 2х и 3х */


/*  Пользоваться данным приёмом можно только для фоновых изображений background-image, поскольку это изображение подключено у нас через CSS.
    Для контентных изображений, подключенных в HTML через тег <img> этот приём не работает. Но здесь тоже нет ничего сложного - для тега
    <img> понадобится просто дополнительный атрибут srcset="" В этом атрибуте прописывается несколько путей к изображениям с разным качеством
    (с разным разрешением), через запятую, чтобы браузер смог из этого уже сам выбирать*/

/*  В HTML записываем элемент <img> следующим образом

            <img 
                srcset="./images/team-1.jpg 1x, ./images/team-1@2x.jpg 2x"  -  перечисляем браузеру варианты загрузки изображений и через пробел после каждого изображения указываем какое из них к какому экрану относится (через т.н. дескриптор х)
                src="./images/team-1.jpg"  - здесь указывается изображение по дефолту на тот случай, если скажем "устаревший" браузер не сможет выбрать изображение по атрибуту srcset - загрузится дефолтное изображение, т.е. обычное изображение на роль "заглушки"
                alt="a member of the team"
                class="team-list__img"
            />
*/

/*  Часто возникают ситуации, когда нужно загрузить для десктопа одно изображение в разрешениях 1х и 2х, для планшета кадрированное
    изображение в другом размере и также в двух версиях 1х и 2х, а также ещё два варианта опять же в другом размере для смартфона в
    двух версиях 1х и 2х. В этом случае техника будет следующая:

    в HTML применяется такой тег как <picture></picture> в который оборачиваются исключительно изображения <img>, также благодаря ему
    расширяется функционал. Внутри тега <picture> используется тег <source> с атрибутами, позволяющими отслеживать ширину вьюпорта

<div class="container">
    <picture>
        <source srcset="./images/img-desktop.jpg" media="(min-width: 1200px)"/>
        <source srcset="./images/img-tablet.jpg"media="(min-width: 768px)" />
        <source srcset="./images/img-mobile.jpg" media="(min-width: 320px)" />

        <img src="./images/img-mobile.jpg" alt="retina picture" class="picture-img" />
    </picture>
</div>

Итак, как это работает? Что браузер делает, когда "натыкается" на эти <source>? Он смотрит, что прописано в условии атрибута media,
и делает свой выбор. Например, читая первый <source> он натыкается на условие media="(min-width: 1200px) - если это условие выполняется,
он возьмёт путь из srcset="/images/img-desktop.jpg" и подставит его в наш <img src="" /> соответственно загрузится изображение по этому 
адресу. Если условие не выполняется - он этот <source> игнорирует и читает следующие <source> пока не выполнится условия из атрибута <source>,
и не подставится нужный адрес изображения.

Тоесть с помощью этой методики мы сделали так, что на разные устройства с разными экранами нам грузятся разные изображения. Теперь, нам
нужно реализовать, чтобы на каждое наше устройство в зависимости от его экрана 1х или 2х браузер подгружал нам на выбор изображение с 
нужным нам разрешением, для этого в атрибуте srcset="" также прописываем через запятую пути к нашим картинкам и проставляем рядом с ними нужный
дискриптор, чтобы браузер понимал какое изображение нужно загрузить. Наш html-код с учётом всего перечисленного примет такой вид:

<div class="container">
    <picture>
        <source
            srcset="./images/img-desktop.jpg 1x, ./images/img-desktop@2x.jpg 2x"
            media="(min-width: 1200px)"
        />
        
        <source
            srcset="./images/img-tablet.jpg 1x, ./images/img-tablet@2x.jpg 2x"
            media="(min-width: 768px)"
         />

        <source
            srcset="./images/img-mobile.jpg 1x, ./images/img-mobile@2x.jpg 2x"
            media="(max-width: 767px)" - для телефонов лучше сделать такое условие, поскольку есть телефоны с 280px вьюпортом и в случае нашего min-width: 320px для них ничего вообще не загрузится.
        />

        <img src="./images/img-mobile.jpg" alt="retina picture" class="picture-img" />
    </picture>
</div>

    Теперь в плане того влияет ли на что-то порядок написания этих <source>? Да влияет. Если браузеру подходит <source>,
    он остальные <source> даже не смотрит. Тоесть если мы используем min-width всегда нужно идти ОТ БОЛЬШЕГО К МЕНЬШЕМУ.

    Таким образом мы предоставили сейчас браузеру на выбор 6 изображений. В зависимости от выполняемых условий - он выберет и
    загрузит только одно.  

    Сейчас изображения всё чаще используются в новом современном Webp формате - он появился в 2012 году и объединил в себе все лучшие
    свойства jpg и png форматов. А именно он хорошо оптимизируется (ужимается) и имеет прозрачные пиксели подобно png. Поэтому, если
    браузер умеет читать webp формат - нужно использовать именно его. Перевести jpg в webp можно с помощью оптимизатора squoosh.app

    Нам нужно сделать так, чтобы браузеры, которые умеют работать с webp (а не все браузеры умеют это делать) - подгружали изображения
    в webp формате, а те, которые не умеют - загружали jpg изображения. Как это реализовать? Нужно выше наших <source> с jpg изображениями
    указать такие же <source> только с webp изображениями, и добавить для них атрибут type="image/webp"

    HTML-код приобретёт такой вид:

        <div class="container">
            <picture>
                <source 
                    srcset="./images/img-desktop.webp 1x, ./images/img-desktop@2x.webp 2x"
                    media="(min-width: 1200px)"
                    type="image/webp"
                />
                <source srcset="./images/img-desktop.jpg 1x, ./images/img-desktop@2x.jpg 2x"
                    media="(min-width: 1200px)"
                />
                <source 
                    srcset="./images/img-tablet.webp 1x, ./images/img-tablet@2x.webp 2x"
                    media="(min-width: 768px)"
                    type="image/webp"
                />
                <source 
                    srcset="./images/img-tablet.jpg 1x, ./images/img-tablet@2x.jpg 2x"
                    media="(min-width: 768px)"
                />
                <source
                    srcset="./images/img-mobile.webp 1x, ./images/img-mobile@2x.webp 2x"
                    media="(max-width: 767px)"
                    type="image/webp"
                />
                <source 
                    srcset="./images/img-mobile.jpg 1x, ./images/img-mobile@2x.jpg 2x"
                    media="(max-width: 767px)"
                /> 
                
                <img src="./images/img-mobile.jpg" alt="retina picture" class="picture-img" />
            </picture>
        </div>

    Браузер прочитает первый <source>, где указан путь к изображениям webp и указан type="image/webp" - если выполнится его медиа-условие
    и браузер умеет работать с type="image/webp", то он загрузит изображение с этим форматом из указанной директории, если нет - 
    проигнорирует этот <source>, и перейдёт к следующему.

    А сейчас мы уже предоставили браузеру на выбор 12 изображений. В зависимости от выполняемых условий - он выберет и загрузит только одно.

    Ещё один важный момент - webp изображение нельзя повесить на фон, поскольку в SCC пока нет медиа-правила, которое могло бы определить
    понимает или нет браузер формат webp. Такая возможность есть пока только в HTML.*/